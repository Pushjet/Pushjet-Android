<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter&nbsp;55.&nbsp;Building native binaries</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide"><link rel="up" href="userguide.html" title="Gradle User Guide"><link rel="prev" href="signing_plugin.html" title="Chapter&nbsp;54.&nbsp;The Signing Plugin"><link rel="next" href="build_lifecycle.html" title="Chapter&nbsp;56.&nbsp;The Build Lifecycle"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="Chapter&nbsp;54.&nbsp;The Signing Plugin">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="Chapter&nbsp;56.&nbsp;The Build Lifecycle">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="nativeBinaries"></a>Chapter&nbsp;55.&nbsp;Building native binaries</h1></div></div></div><div class="note"><p>
            The Gradle support for building native binaries is currently <a class="link" href="feature_lifecycle.html">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.
        </p></div><p>
        The various native binary plugins add support for building native software components, such as executables
        or shared libraries, from code written in C++, C and other languages. While many excellent build tools exist
        for this space of software development, Gradle offers developers its trademark power and flexibility
        together with dependency management practices more traditionally found in the JVM development space.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15B29"></a>55.1.&nbsp;Supported languages</h2></div></div></div><p>
            The following source languages are currently supported:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>C</p></li><li class="listitem"><p>C++</p></li><li class="listitem"><p>Objective-C</p></li><li class="listitem"><p>Objective-C++</p></li><li class="listitem"><p>Assembly</p></li><li class="listitem"><p>Windows resources</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native-binaries:tool-chain-support"></a>55.2.&nbsp;Tool chain support</h2></div></div></div><p>
            Gradle offers the ability to execute the same build using different tool chains. When you build a native binary, Gradle will attempt to locate a
            tool chain installed on your machine that can build the binary. You can fine tune exactly how this works,
            see <a class="xref" href="nativeBinaries.html#native_binaries:tool_chain">Section&nbsp;55.14, &ldquo;Tool chains&rdquo;</a> for details.
        </p><p>
            The following tool chains are supported:
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N15B4C"><thead><tr><td>Operating System</td><td>Tool Chain</td><td>Notes</td></tr></thead><tr>
                <td>Linux</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td> <td></td>
            </tr><tr>
                <td>Linux</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td><td></td>
            </tr><tr>
                <td>Mac OS X</td><td>XCode</td><td>Uses the Clang tool chain bundled with XCode.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://www.microsoft.com/visualstudio/en-us" target="_top">Visual C++</a></td><td>Windows XP and later, Visual C++ 2010 and later.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> with <a class="ulink" href="http://cygwin.com" target="_top">Cywin 32</a></td><td>Windows XP and later.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> with <a class="ulink" href="http://www.mingw.org/" target="_top">MinGW</a></td><td>Windows XP and later. <a class="ulink" href="http://mingw-w64.sourceforge.net" target="_top">Mingw-w64</a> is currently not supported.</td>
            </tr></table></div></div><p>
            The following tool chains are unofficially supported. They generally work fine, but are not tested continuously:
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N15BA2"><thead><tr><td>Operating System</td><td>Tool Chain</td><td>Notes</td></tr></thead><tr>
                <td>Mac OS X</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> from Macports</td><td></td>
            </tr><tr>
                <td>Mac OS X</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a> from Macports</td><td></td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> with <a class="ulink" href="http://cygwin.com" target="_top">Cywin 64</a></td><td>Windows XP and later.</td>
            </tr><tr>
                <td>UNIX-like</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td><td></td>
            </tr><tr>
                <td>UNIX-like</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td><td></td>
            </tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15BE4"></a>55.3.&nbsp;Tool chain installation</h2></div></div></div><div class="note"><p>
                Note that if you are using GCC then you currently need to install support for C++, even if you are not building from C++ source. This caveat will be removed in a future Gradle version.
            </p></div><p>To build native binaries, you will need to have a compatible tool chain installed:
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15BEC"></a>55.3.1.&nbsp;Windows</h3></div></div></div><p>To build on Windows, install a compatible version of Visual Studio. The native plugins will discover the Visual Studio installations
                and select the latest version. There is no need to mess around with environment variables or batch scripts. This works fine from a Cygwin shell
                or the Windows command-line.
            </p><p>Alternatively, you can install Cygwin with GCC or MinGW. Clang is currently not supported.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15BF3"></a>55.3.2.&nbsp;OS X</h3></div></div></div><p>To build on OS X, you should install XCode. The native plugins will discover the XCode installation using the system PATH.
            </p><p>
                The native plugins also work with GCC and Clang bundled with Macports. To use one of the Macports tool chains,
                you will need to make the tool chain the default using the <strong class="userinput"><code>port select</code></strong> command and add Macports to the system PATH.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15BFD"></a>55.3.3.&nbsp;Linux</h3></div></div></div><p>To build on Linux, install a compatible version of GCC or Clang. The native plugins will discover GCC or Clang using the system PATH.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15C02"></a>55.4.&nbsp;Component model</h2></div></div></div><p>
            To build native binaries using Gradle, your project should define one or more <em class="firstterm">native components</em>. Each component represents either an
            executable or a library that Gradle should build. A project can define any number of components. Gradle does not define any components by default.
        </p><p>
            For each component, Gradle defines a <em class="firstterm">source set</em> for each language that the component can be built from. A source set is essentially
            just a set of source directories containing source files. For example, when you apply the <code class="literal">c</code> plugin and define a library called
            <code class="literal">helloworld</code>, Gradle will define, by default, a source set containing the C source files in the <code class="literal">src/helloworld/c</code> directory.
            It will use these source files to build the <code class="literal">helloworld</code> library.
            This is described in more detail below.
        </p><p>
            For each component, Gradle defines one or more <em class="firstterm">binaries</em> as output. To build a binary, Gradle will take the source files defined for
            the component, compile them as appropriate for the source language, and link the result into a binary file. For an executable component, Gradle can
            produce executable binary files. For a library component, Gradle can produce both static and shared library binary files. For example, when you define
            a library called <code class="literal">helloworld</code> and build on Linux, Gradle will, by default, produce <code class="filename">libhelloworld.so</code> and
            <code class="filename">libhelloworld.a</code> binaries.
        </p><p>
            In many cases, more than one binary can be produced for a component.
            These binaries may vary based on the tool chain used to build, the compiler/linker flags supplied, the dependencies
            provided, or additional source files provided. Each native binary produced for a component is referred to as <em class="firstterm">variant</em>.
            Binary variants are discussed in detail below.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15C2E"></a>55.5.&nbsp;Building a library</h2></div></div></div><p>
            To build either a static or shared native library, you define a library component in the <code class="literal">libraries</code> container. The following sample
            defines a library called <code class="literal">hello</code>:
        </p><div class="example"><a name="cppLibraries"></a><p class="title"><b>Example&nbsp;55.1.&nbsp;Defining a library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    hello {}
}</pre></div></div><br class="example-break"><p>
            A library component is represented using <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a>.
            Each library component can produce at least one shared library binary (<a class="ulink" href="../dsl/org.gradle.nativeplatform.SharedLibraryBinarySpec.html" target="_top"><code class="classname">SharedLibraryBinarySpec</code></a>)
            and at least one static library binary (<a class="ulink" href="../dsl/org.gradle.nativeplatform.StaticLibraryBinarySpec.html" target="_top"><code class="classname">StaticLibraryBinarySpec</code></a>).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15C54"></a>55.6.&nbsp;Building an executable</h2></div></div></div><p>
            To build a native executable, you define an executable component in the <code class="literal">executables</code> container. The following sample defines
            an executable called <code class="literal">main</code>:
        </p><div class="example"><a name="cppExecutables"></a><p class="title"><b>Example&nbsp;55.2.&nbsp;Defining executable components</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {}
}</pre></div></div><br class="example-break"><p>
            An executable component is represented using <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a>. Each executable component can
            produce at least one executable binary (<a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableBinarySpec.html" target="_top"><code class="classname">NativeExecutableBinarySpec</code></a>).
        </p><p>
            For each component defined, Gradle adds a <a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a> with the same name.
            Each of these functional source sets will contain a language-specific source set for each of the languages supported by the project.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15C7C"></a>55.7.&nbsp;Tasks</h2></div></div></div><p>
            For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> that can be produced by a build,
            a single <em class="firstterm">lifecycle task</em> is constructed that can be used to create that binary, together with a set of other tasks that do the actual
            work of compiling, linking or assembling the binary.
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N15C89"><thead><tr>
                    <td>Component Type</td>
                    <td>Native Binary Type</td>
                    <td>Lifecycle task</td>
                    <td>Location of created binary</td>
                </tr></thead><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a></td>
                <td><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableBinarySpec.html" target="_top"><code class="classname">NativeExecutableBinarySpec</code></a></td>
                <td><code class="literal"><em class="replaceable"><code>${component.name}</code></em>Executable</code></td>
                <td><code class="filename"><em class="replaceable"><code>${project.buildDir}</code></em>/binaries/<em class="replaceable"><code>${component.name}</code></em>Executable/<em class="replaceable"><code>${component.name}</code></em></code></td>
            </tr><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a></td>
                <td><a class="ulink" href="../dsl/org.gradle.nativeplatform.SharedLibraryBinarySpec.html" target="_top"><code class="classname">SharedLibraryBinarySpec</code></a></td>
                <td><code class="literal"><em class="replaceable"><code>${component.name}</code></em>SharedLibrary</code></td>
                <td><code class="filename"><em class="replaceable"><code>${project.buildDir}</code></em>/binaries/<em class="replaceable"><code>${component.name}</code></em>SharedLibrary/lib<em class="replaceable"><code>${component.name}</code></em>.so</code></td>
            </tr><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a></td>
                <td><a class="ulink" href="../dsl/org.gradle.nativeplatform.StaticLibraryBinarySpec.html" target="_top"><code class="classname">StaticLibraryBinarySpec</code></a></td>
                <td><code class="literal"><em class="replaceable"><code>${component.name}</code></em>StaticLibrary</code></td>
                    <td><code class="filename"><em class="replaceable"><code>${project.buildDir}</code></em>/binaries/<em class="replaceable"><code>${component.name}</code></em>StaticLibrary/<em class="replaceable"><code>${component.name}</code></em>.a</code></td>
            </tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15CF8"></a>55.7.1.&nbsp;Working with shared libraries</h3></div></div></div><p>
                For each executable binary produced, the <code class="literal">cpp</code> plugin provides an <code class="literal">install${binary.name}</code> task,
                which creates a development install of the executable, along with the shared libraries it requires.
                This allows you to run the executable without needing to install the shared libraries in their final locations.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15D03"></a>55.8.&nbsp;Finding out more about your project</h2></div></div></div><p>Gradle provides a report that you can run from the command-line that shows some details about the components and binaries that your
            project produces. To use this report, just run <strong class="userinput"><code>gradle components</code></strong>. Below is an example of running this report for
            one of the sample projects:
        </p><div class="example"><a name="nativeComponentReport"></a><p class="title"><b>Example&nbsp;55.3.&nbsp;The components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle components</code></strong></p><pre class="screen">&gt; gradle components
:components

------------------------------------------------------------
Root project
------------------------------------------------------------

Native library 'hello'
----------------------

Source sets
    C++ source 'hello:cpp'
        src/hello/cpp

Binaries
    Shared library 'hello:sharedLibrary'
        build using task: :helloSharedLibrary
        platform: current
        build type: debug
        flavor: default
        tool chain: Tool chain 'clang' (Clang)
        shared library file: build/binaries/helloSharedLibrary/libhello.dylib
    Static library 'hello:staticLibrary'
        build using task: :helloStaticLibrary
        platform: current
        build type: debug
        flavor: default
        tool chain: Tool chain 'clang' (Clang)
        static library file: build/binaries/helloStaticLibrary/libhello.a

Native executable 'main'
------------------------

Source sets
    C++ source 'main:cpp'
        src/main/cpp

Binaries
    Executable 'main:executable'
        build using task: :mainExecutable
        platform: current
        build type: debug
        flavor: default
        tool chain: Tool chain 'clang' (Clang)
        executable file: build/binaries/mainExecutable/main

Note: currently not all plugins register their components, so some components may not be visible here.

BUILD SUCCESSFUL

Total time: 1 secs</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:languages"></a>55.9.&nbsp;Language support</h2></div></div></div><p>
            Presently, Gradle supports building native binaries from any combination of source languages listed below.
            A native binary project will contain one or more named <code class="literal">FunctionalSourceSet</code> instances (eg 'main', 'test', etc),
            each of which can contain <code class="literal">LanguageSourceSet</code>s containing source files, one for each language.
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>C</p></li><li class="listitem"><p>C++</p></li><li class="listitem"><p>Objective-C</p></li><li class="listitem"><p>Objective-C++</p></li><li class="listitem"><p>Assembly</p></li><li class="listitem"><p>Windows resources</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15D34"></a>55.9.1.&nbsp;C++ sources</h3></div></div></div><p>
                C++ language support is provided by means of the <code class="literal">'cpp'</code> plugin.
            </p><div class="example"><a name="cppPlugin"></a><p class="title"><b>Example&nbsp;55.4.&nbsp;The 'cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'cpp'</span></pre></div></div><br class="example-break"><p>
                C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>,
                which defines a set of C++ source files and optionally a set of exported header files (for a library).
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a> contains
                <code class="filename">.cpp</code> source files in <code class="filename">src/${name}/cpp</code>,
                and header files in <code class="filename">src/${name}/headers</code>.
            </p><p>
                While the <code class="literal">cpp</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>,
                it is possible to extend or override these defaults to allow for a different project layout.
            </p><div class="example"><a name="cppSourceSet"></a><p class="title"><b>Example&nbsp;55.5.&nbsp;C++ source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.cpp"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a library named 'main', header files in <code class="filename">src/main/headers</code> are considered the &ldquo;public&rdquo; or &ldquo;exported&rdquo; headers.
                Header files that should not be exported should be placed inside the <code class="filename">src/main/cpp</code> directory (though be aware that
                such header files should always be referenced in a manner relative to the file including them).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15D77"></a>55.9.2.&nbsp;C sources</h3></div></div></div><p>
                C language support is provided by means of the <code class="literal">'c'</code> plugin.
            </p><div class="example"><a name="cPlugin"></a><p class="title"><b>Example&nbsp;55.6.&nbsp;The 'c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'c'</span></pre></div></div><br class="example-break"><p>
                C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>,
                which defines a set of C source files and optionally a set of exported header files (for a library).
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> contains
                <code class="filename">.c</code> source files in <code class="filename">src/${name}/c</code>,
                and header files in <code class="filename">src/${name}/headers</code>.
            </p><p>
                While the <code class="literal">c</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>,
                it is possible to extend or override these defaults to allow for a different project layout.
            </p><div class="example"><a name="cSourceSet"></a><p class="title"><b>Example&nbsp;55.7.&nbsp;C source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    hello {
        c {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.c"</span>
            }
            exportedHeaders {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/include"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a library named 'main', header files in <code class="filename">src/main/headers</code> are considered the &ldquo;public&rdquo; or &ldquo;exported&rdquo; headers.
                Header files that should not be exported should be placed inside the <code class="filename">src/main/c</code> directory (though be aware that
                such header files should always be referenced in a manner relative to the file including them).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15DBA"></a>55.9.3.&nbsp;Assembler sources</h3></div></div></div><p>
                Assembly language support is provided by means of the <code class="literal">'assembler'</code> plugin.
            </p><div class="example"><a name="assemblerPlugin"></a><p class="title"><b>Example&nbsp;55.8.&nbsp;The 'assembler' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'assembler'</span></pre></div></div><br class="example-break"><p>
                Assembler sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>,
                which defines a set of Assembler source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a> contains
                <code class="filename">.s</code> source files under <code class="filename">src/${name}/asm</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15DDE"></a>55.9.4.&nbsp;Objective-C sources</h3></div></div></div><p>
                Objective-C language support is provided by means of the <code class="literal">'objective-c'</code> plugin.
            </p><div class="example"><a name="objectiveCPlugin"></a><p class="title"><b>Example&nbsp;55.9.&nbsp;The 'objective-c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'objective-c'</span></pre></div></div><br class="example-break"><p>
                Objective-C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a>,
                which defines a set of Objective-C source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a> contains
                <code class="filename">.m</code> source files under <code class="filename">src/${name}/objectiveC</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15E02"></a>55.9.5.&nbsp;Objective-C++ sources</h3></div></div></div><p>
                Objective-C++ language support is provided by means of the <code class="literal">'objective-cpp'</code> plugin.
            </p><div class="example"><a name="objectiveCppPlugin"></a><p class="title"><b>Example&nbsp;55.10.&nbsp;The 'objective-cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'objective-cpp'</span></pre></div></div><br class="example-break"><p>
                Objective-C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a>,
                which defines a set of Objective-C++ source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a> contains
                <code class="filename">.mm</code> source files under <code class="filename">src/${name}/objectiveCpp</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15E26"></a>55.10.&nbsp;Configuring the compiler, assembler and linker</h2></div></div></div><p>
            Each binary to be produced is associated with a set of compiler and linker settings, which include command-line arguments as well as macro definitions.
            These settings can be applied to all binaries, an individual binary, or selectively to a group of binaries based on some criteria.
        </p><div class="example"><a name="allBinarySettings"></a><p class="title"><b>Example&nbsp;55.11.&nbsp;Settings that apply to all binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro for every binary</span>
    cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"NDEBUG"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define toolchain-specific compiler and linker options</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-O2"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-fno-access-control"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-Xlinker"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-S"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/DEBUG"</span>
    }
}</pre></div></div><br class="example-break"><p>
            Each binary is associated with a particular <a class="ulink" href="../javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html" target="_top"><code class="classname">NativeToolChain</code></a>, allowing settings to be targeted based on
            this value.
        </p><p>
            It is easy to apply settings to all binaries of a particular type:
        </p><div class="example"><a name="allSharedLibraryBinarySettings"></a><p class="title"><b>Example&nbsp;55.12.&nbsp;Settings that apply to all shared libraries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// For any shared library binaries built with Visual C++,</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// define the DLL_EXPORT macro</span>
binaries.withType(SharedLibraryBinarySpec) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
    }
}</pre></div></div><br class="example-break"><p>
            Furthermore, it is possible to specify settings that apply to all binaries produced for a particular <code class="literal">executable</code>
            or <code class="literal">library</code> component:
        </p><div class="example"><a name="componentBinarySettings"></a><p class="title"><b>Example&nbsp;55.13.&nbsp;Settings that apply to all binaries produced for the 'main' executable component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
            } <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">else</span> {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
            }
        }
    }
}

sources {
    i3<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">86</span>_masm {
        asm(AssemblerSourceSet) {
            source.srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/main/asm_i386_masm"</span>
        }
    }
    i3<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">86</span>_gcc {
        asm(AssemblerSourceSet) {
            source.srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/main/asm_i386_gcc"</span>
        }
    }
}</pre></div></div><br class="example-break"><p>
            The example above will apply the supplied configuration to all <code class="literal">executable</code> binaries built.
        </p><p>
            Similarly, settings can be specified to target binaries for a component that are of a particular type:
            eg all shared libraries for the main library component.
        </p><div class="example"><a name="sharedLibraryArgs"></a><p class="title"><b>Example&nbsp;55.14.&nbsp;Settings that apply only to shared libraries produced for the 'main' library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    main {
        binaries.withType(SharedLibraryBinarySpec) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro that only applies to shared libraries</span>
            cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:windows-resources"></a>55.11.&nbsp;Windows Resources</h2></div></div></div><p>
            When using the <a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a> tool chain, Gradle is able to compile Window Resource (<code class="literal">rc</code>)
            files and link them into a native binary. This functionality is provided by the <code class="literal">'windows-resources'</code> plugin.
        </p><div class="example"><a name="windowsResourcesPlugin"></a><p class="title"><b>Example&nbsp;55.15.&nbsp;The 'windows-resources' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'windows-resources'</span></pre></div></div><br class="example-break"><p>
            Windows resources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a>,
            which defines a set of Windows Resource source files.
            By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a> contains
            <code class="filename">.rc</code> source files under <code class="filename">src/${name}/rc</code>.
        </p><p>
            As with other source types, you can configure the location of the windows resources that should be included in the binary.
        </p><div class="example"><a name="windowsResourceSet"></a><p class="title"><b>Example&nbsp;55.16.&nbsp;Configuring the location of Windows resource sources</b></p><div class="example-contents"><p><code class="filename">build-resource-only-dll.gradle</code></p><pre class="programlisting">sources {
    helloRes {
        rc {
            source {
                srcDirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/hello/rc"</span>
            }
            exportedHeaders {
                srcDirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/hello/headers"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
            You are able to construct a resource-only library by providing Windows Resource sources with no other language sources,
            and configure the linker as appropriate:
        </p><div class="example"><a name="resourceOnlyDll"></a><p class="title"><b>Example&nbsp;55.17.&nbsp;Building a resource-only dll</b></p><div class="example-contents"><p><code class="filename">build-resource-only-dll.gradle</code></p><pre class="programlisting">libraries {
    helloRes {
        binaries.all {
            rcCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/v"</span>
            linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/noentry"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/machine:x86"</span>
        }
    }
}</pre></div></div><br class="example-break"><p>
            The example above also demonstrates the mechanism of passing extra command-line arguments to the resource compiler.
            The <code class="literal">rcCompiler</code> extension is of type <a class="ulink" href="../dsl/org.gradle.language.PreprocessingTool.html" target="_top"><code class="classname">PreprocessingTool</code></a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15EBA"></a>55.12.&nbsp;Library Dependencies</h2></div></div></div><p>
            Dependencies for native components are binary libraries that export header files. The header files are used during compilation, with the compiled
            binary dependency being used during linking and execution.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15EBF"></a>55.12.1.&nbsp;Dependencies within the same project</h3></div></div></div><p>
               A set of sources may depend on header files provided by another binary component within the same project.
               A common example is a native executable component that uses functions provided by a separate native library component.
           </p><p>
               Such a library dependency can be added to a source set associated with the <code class="literal">executable</code> component:
           </p><div class="example"><a name="cppSourceLibrary"></a><p class="title"><b>Example&nbsp;55.18.&nbsp;Providing a library dependency to the source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            lib libraries.hello
        }
    }
}</pre></div></div><br class="example-break"><p>
               Alternatively, a library dependency can be provided directly to the <code class="literal">NativeExecutableBinary</code> for the <code class="literal">executable</code>.
           </p><div class="example"><a name="cppBinaryLibrary"></a><p class="title"><b>Example&nbsp;55.19.&nbsp;Providing a library dependency to the binary</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Each executable binary produced uses the 'hello' static library binary</span>
            lib libraries.hello.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">static</span>
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15EE5"></a>55.12.2.&nbsp;Project Dependencies</h3></div></div></div><p>
                For a component produced in a different Gradle project, the notation is similar.
            </p><div class="example"><a name="cppProjectDependencies"></a><p class="title"><b>Example&nbsp;55.20.&nbsp;Declaring project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":lib"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp"</span>
    libraries {
        main {}
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// For any shared library binaries built with Visual C++,</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// define the DLL_EXPORT macro</span>
    binaries.withType(SharedLibraryBinarySpec) {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
            cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
        }
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":exe"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp"</span>

    executables {
        main {}
    }

    sources {
        main {
            cpp {
                lib project: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':lib'</span>, library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'main'</span>
            }
        }
    }
}</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:variants"></a>55.13.&nbsp;Native Binary Variants</h2></div></div></div><p>
            For each executable or library defined, Gradle is able to build a number of different native binary variants.
            Examples of different variants include debug vs release binaries, 32-bit vs 64-bit binaries, and binaries produced
            with different custom preprocessor flags.
        </p><p>
            Binaries produced by Gradle can be differentiated on
                <a class="link" href="nativeBinaries.html#native_binaries:build_type">build type</a>,
                <a class="link" href="nativeBinaries.html#native_binaries:platform">platform</a>, and
                <a class="link" href="nativeBinaries.html#native_binaries:flavor">flavor</a>.
            For each of these 'variant dimensions', it is possible to specify a set of available values as well as target each component at
            one, some or all of these. For example, a plugin may define a range of support platforms, but you
            may choose to only target Windows-x86 for a particular component.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:build_type"></a>55.13.1.&nbsp;Build types</h3></div></div></div><p>
                A <code class="literal">build type</code> determines various non-functional aspects of a binary, such as whether debug information is included,
                or what optimisation level the binary is compiled with. Typical build types are 'debug' and 'release', but a project
                is free to define any set of build types.
            </p><div class="example"><a name="buildTypes"></a><p class="title"><b>Example&nbsp;55.21.&nbsp;Defining build types</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    buildTypes {
        debug
        release
    }
}</pre></div></div><br class="example-break"><p>
                If no build types are defined in a project, then a single, default build type called 'debug' is added.
            </p><p>
                For a build type, a Gradle project will typically define a set of compiler/linker flags per tool chain.
            </p><div class="example"><a name="buildTypeConfig"></a><p class="title"><b>Example&nbsp;55.22.&nbsp;Configuring debug binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/Zi'</span>
        cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'DEBUG'</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/DEBUG'</span>
    }
}</pre></div></div><br class="example-break"><div class="note">
                At this stage, it is completely up to the build script to configure the relevant compiler/linker flags for each
                build type. Future versions of Gradle will automatically include the appropriate debug flags for any 'debug' build
                type, and may be aware of various levels of optimisation as well.
            </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:platform"></a>55.13.2.&nbsp;Platform</h3></div></div></div><p>
                An executable or library can be built to run on different operating systems and cpu architectures, with a variant being
                produced for each platform. Gradle defines each OS/architecture combination as a <a class="ulink" href="../javadoc/org/gradle/nativeplatform/platform/NativePlatform.html" target="_top"><code class="classname">NativePlatform</code></a>,
                and a project may define any number of platforms.
                If no platforms are defined in a project, then a single, default platform 'current' is added.
            </p><div class="note">
                Presently, a <code class="literal">Platform</code> consists of a defined operating system and architecture. As we continue to develop the
                native binary support in Gradle, the concept of Platform will be extended to include things like C-runtime version, Windows SDK, ABI, etc.
                Sophisticated builds may use the extensibility of Gradle to apply additional attributes to each platform, which can then be queried to
                specify particular includes, preprocessor macros or compiler arguments for a native binary.
            </div><div class="example"><a name="platforms"></a><p class="title"><b>Example&nbsp;55.23.&nbsp;Defining platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    platforms {
        x8<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span> {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>
        }
        x6<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span> {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86_64"</span>
        }
        itanium {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ia-64"</span>
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a given variant, Gradle will attempt to find a <a class="ulink" href="../javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html" target="_top"><code class="classname">NativeToolChain</code></a> that is able to build
                for the target platform. Available tool chains are searched in the order defined.
                See the <a class="link" href="nativeBinaries.html#native_binaries:tool_chain">tool chains</a> section below for more details.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:flavor"></a>55.13.3.&nbsp;Flavor</h3></div></div></div><p>
                Each component can have a set of named <code class="literal">flavors</code>, and a separate binary variant can be produced for each flavor.
                While the <code class="literal">build type</code> and <code class="literal">target platform</code> variant dimensions have a defined meaning in Gradle,
                each project is free to define any number of flavors and apply meaning to them in any way.
            </p><p>
                An example of component flavors might differentiate between 'demo', 'paid' and 'enterprise' editions of the component,
                where the same set of sources is used to produce binaries with different functions.
            </p><div class="example"><a name="flavors"></a><p class="title"><b>Example&nbsp;55.24.&nbsp;Defining flavors</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    flavors {
        english
        french
    }
}

libraries {
    hello {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.french) {
                cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"FRENCH"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                In the example above, a library is defined with a 'english' and 'french' flavor. When compiling the 'french'
                variant, a separate macro is defined which leads to a different binary being produced.
            </p><p>
                If no flavor is defined for a component, then a single default flavor named 'default' is used.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15F6F"></a>55.13.4.&nbsp;Selecting the build types, platforms and flavors for a component</h3></div></div></div><p>
                For a default component, Gradle will attempt to create a native binary variant for each and every combination of <code class="literal">buildType</code>,
                <code class="literal">platform</code> and <code class="literal">flavor</code> defined for the project. It is possible to override this on a per-component
                basis, by specifying the set of <code class="literal">targetBuildTypes</code>, <code class="literal">targetPlatform</code> and/or <code class="literal">targetFlavors</code>.
            </p><div class="example"><a name="targets"></a><p class="title"><b>Example&nbsp;55.25.&nbsp;Targeting a component at particular platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        targetPlatforms <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x64"</span>
    }
}</pre></div></div><br class="example-break"><p>
                Here you can see that the <a class="ulink" href="../dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetPlatforms(java.lang.String[])" target="_top"><code class="classname">TargetedNativeComponent.targetPlatforms()</code></a> method is used to
                select the set of platforms to target for <code class="literal">executables.main</code>.
            </p><p>
                A similar mechanism exists for selecting <a class="ulink" href="../dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetBuildTypes(java.lang.String[])" target="_top"><code class="classname">TargetedNativeComponent.targetBuildTypes()</code></a>
                and <a class="ulink" href="../dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetFlavors(java.lang.String[])" target="_top"><code class="classname">TargetedNativeComponent.targetFlavors()</code></a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15FA6"></a>55.13.5.&nbsp;Building all possible variants</h3></div></div></div><p>
                When a set of build types, target platforms, and flavors is defined for a component,
                a <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> model element is created for every possible
                combination of these. However, in many cases it is not possible to build a particular variant, perhaps because
                no tool chain is available to build for a particular platform.
            </p><p>
                If a binary variant cannot be built for any reason, then the <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a>
                associated with that variant will not be <code class="literal">buildable</code>. It is possible to use this property to create a task
                to generate all possible variants on a particular machine.
            </p><div class="example"><a name="buildable"></a><p class="title"><b>Example&nbsp;55.26.&nbsp;Building all possible variants</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task buildAllExecutables {
    dependsOn binaries.withType(NativeExecutableBinary).matching {
        it.buildable
    }
}</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:tool_chain"></a>55.14.&nbsp;Tool chains</h2></div></div></div><p>
            A single build may utilize different tool chains to build variants for different platforms. To this end,
            the core 'native-binary' plugins will attempt to locate and make available supported tool chains. However, the set
            of tool chains for a project may also be explicitly defined, allowing additional cross-compilers to be configured
            as well as allowing the install directories to be specified.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15FCA"></a>55.14.1.&nbsp;Defining tool chains</h3></div></div></div><p>
                The supported tool chain types are:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a></p></li></ul></div><div class="example"><a name="toolChains"></a><p class="title"><b>Example&nbsp;55.27.&nbsp;Defining tool chains</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        visualCpp(VisualCpp) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Specify the installDir if Visual Studio cannot be located</span>
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// installDir "C:/Apps/Microsoft Visual Studio 10.0"</span>
        }
        gcc(Gcc) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Uncomment to use a GCC install that is not in the PATH</span>
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// path "/usr/bin/gcc"</span>
        }
        clang(Clang)
    }
}</pre></div></div><br class="example-break"><p>
                Each tool chain implementation allows for a certain degree of configuration (see the API documentation for more details).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15FEE"></a>55.14.2.&nbsp;Using tool chains</h3></div></div></div><p>
                It is not necessary or possible to specify the tool chain that should be used to build.
                For a given variant, Gradle will attempt to locate a <a class="ulink" href="../javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html" target="_top"><code class="classname">NativeToolChain</code></a> that is able to build
                for the target platform. Available tool chains are searched in the order defined.
            </p><div class="note">
                When a platform does not define an architecture or operating system, the default target of the tool chain
                is assumed. So if a platform does not define a value for <code class="literal">operatingSystem</code>,
                Gradle will find the first available tool chain that can build for the specified <code class="literal">architecture</code>.
            </div><p>
                The core Gradle tool chains are able to target the following architectures out of the box. In each case, the tool chain
                will target the current operating system. See the next section for information on cross-compiling for other operating systems.
            </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N16002"><thead><tr><td>Tool Chain</td><td>Architectures</td></tr></thead><tr>
                    <td>GCC</td><td>x86, x86_64</td>
                </tr><tr>
                    <td>Clang</td><td>x86, x86_64</td>
                </tr><tr>
                    <td>Visual C++</td><td>x86, x86_64, ia-64</td>
                </tr></table></div></div><p>
                So for GCC running on linux, the supported target platforms are 'linux/x86' and 'linux/x86_64'.
                For GCC running on Windows via Cygwin, platforms 'windows/x86' and 'windows/x86_64' are supported.
                (The Cygwin POSIX runtime is not yet modelled as part of the platform, but will be in the future.)
            </p><p>
                If no target platforms are defined for a project, then all binaries are built to target a default platform named 'current'.
                This default platform does not specify any <code class="literal">architecture</code> or <code class="literal">operatingSystem</code> value,
                hence using the default values of the first available tool chain.
            </p><p>
                Gradle provides a <em class="firstterm">hook</em> that allows the build author to control the exact set of arguments passed to a tool chain executable.
                This enables the build author to work around any limitations in Gradle, or assumptions that Gradle makes.
                The arguments hook should be seen as a 'last-resort' mechanism, with preference given to truly modelling the underlying domain.
            </p><div class="example"><a name="withArguments"></a><p class="title"><b>Example&nbsp;55.28.&nbsp;Reconfigure tool arguments</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        visualCpp(VisualCpp) {
            eachPlatform {
                cppCompiler.withArguments { args -&gt;
                    args &lt;&lt; <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-DFRENCH"</span>
                }
            }
        }
        clang(Clang) {
            eachPlatform {
                cCompiler.withArguments { args -&gt;
                    Collections.replaceAll(args, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"CUSTOM"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-DFRENCH"</span>)
                }
                linker.withArguments { args -&gt;
                    args.remove <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"CUSTOM"</span>
                }
                staticLibArchiver.withArguments { args -&gt;
                    args.remove <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"CUSTOM"</span>
                }
            }
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N16037"></a>55.14.3.&nbsp;Cross-compiling with GCC</h3></div></div></div><p>
                Cross-compiling is possible with the <a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a> and <a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a> tool chains,
                by adding support for additional target platforms.
                This is done by specifying a target platform for a toolchain. For each target platform a custom configuration can be specified.
            </p><div class="example"><a name="targetPlatforms"></a><p class="title"><b>Example&nbsp;55.29.&nbsp;Defining target platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        gcc(Gcc) {
            target(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"arm"</span>){
                cppCompiler.withArguments { args -&gt;
                    args &lt;&lt; <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-m32"</span>
                }
                linker.withArguments { args -&gt;
                    args &lt;&lt; <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-m32"</span>
                }
            }
            target(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sparc"</span>)
        }
    }
    platforms {
        arm {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"arm"</span>
        }
        sparc {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sparc"</span>
        }
    }
}</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:visual_studio"></a>55.15.&nbsp;Visual Studio IDE integration</h2></div></div></div><p>
            Gradle has the ability to generate Visual Studio project and solution files for the native components defined in your build.
            This ability is added by the <code class="literal">visual-studio</code> plugin. For a multi-project build, all projects with native components
            should have this plugin applied.
        </p><p>
            When the <code class="literal">visual-studio</code> plugin is applied, a task name <code class="literal">${component.name}VisualStudio</code> is created
            for each defined component. This task will generate a Visual Studio Solution file for the named component. This solution will include
            a Visual Studio Project for that component, as well as linking to project files for each depended-on binary.
        </p><p>
            The content of the generated visual studio files can be modified via API hooks, provided by the <code class="literal">visualStudio</code>
            extension. Take a look at the 'visual-studio' sample, or see <a class="ulink" href="../dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:projects" target="_top"><code class="classname">VisualStudioExtension.getProjects()</code></a>
            and <a class="ulink" href="../dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:solutions" target="_top"><code class="classname">VisualStudioExtension.getSolutions()</code></a> in the API documentation for more details.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:cunit"></a>55.16.&nbsp;CUnit support</h2></div></div></div><p>
            The Gradle <code class="literal">cunit</code> plugin provides support for compiling and executing CUnit tests in your native-binary project.
            For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a> and <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a>
            defined in your project, Gradle will create a matching <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html" target="_top"><code class="classname">CUnitTestSuiteSpec</code></a> component,
            named <code class="literal">${component.name}Test</code>.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N1608B"></a>55.16.1.&nbsp;CUnit sources</h3></div></div></div><p>
                Gradle will create a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> named 'cunit' for each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html" target="_top"><code class="classname">CUnitTestSuiteSpec</code></a> component
                in the project. This source set should contain the cunit test files for the component sources. Source files can be located in the conventional location
                (<code class="literal">src/${component.name}Test/cunit</code>) or can be configured like any other source set.
            </p><p>
                Gradle initialises the CUnit test registry and executes the tests, utilising some generated CUnit launcher sources.
                Gradle will expect and call a function with the signature <code class="literal">void gradle_cunit_register()</code> that you can use to configure the
                actual CUnit suites and tests to execute.
            </p><div class="example"><a name="cunitSources"></a><p class="title"><b>Example&nbsp;55.30.&nbsp;Registering CUnit tests</b></p><div class="example-contents"><p><code class="filename">suite_operators.c</code></p><pre class="programlisting">#include &lt;CUnit/Basic.h&gt;
#include "gradle_cunit_register.h"
#include "test_operators.h"

int suite_init(void) {
    return 0;
}

int suite_clean(void) {
    return 0;
}

void gradle_cunit_register() {
    CU_pSuite pSuiteMath = CU_add_suite("operator tests", suite_init, suite_clean);
    CU_add_test(pSuiteMath, "test_plus", test_plus);
    CU_add_test(pSuiteMath, "test_minus", test_minus);
}</pre></div></div><br class="example-break"><div class="note">
                Due to this mechanism, your CUnit sources may not contain a <code class="literal">main</code> method since this will clash with the method provided by Gradle.
            </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N160B0"></a>55.16.2.&nbsp;Building CUnit executables</h3></div></div></div><p>
                A <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html" target="_top"><code class="classname">CUnitTestSuiteSpec</code></a> component has an associated
                <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a> or <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a> component.
                For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> configured for the main component, a matching
                <a class="ulink" href="../javadoc/org/gradle/nativeplatform/test/cunit/CUnitTestSuiteBinarySpec.html" target="_top"><code class="classname">CUnitTestSuiteBinarySpec</code></a> will be configured on the test suite component.
                These test suite binaries can be configured in a similar way to any other binary instance:
            </p><div class="example"><a name="cunitSources"></a><p class="title"><b>Example&nbsp;55.31.&nbsp;Registering CUnit tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.withType(CUnitTestSuiteBinarySpec) {
    lib library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>, linkage: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"static"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.failing) {
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"PLUS_BROKEN"</span>
    }
}</pre></div></div><br class="example-break"><div class="note">
                Both the CUnit sources provided by your project and the generated launcher require the core CUnit headers and libraries.
                Presently, this library dependency must be provided by your project for each <a class="ulink" href="../javadoc/org/gradle/nativeplatform/test/cunit/CUnitTestSuiteBinarySpec.html" target="_top"><code class="classname">CUnitTestSuiteBinarySpec</code></a>.
            </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N160DF"></a>55.16.3.&nbsp;Running CUnit tests</h3></div></div></div><p>
                For each <a class="ulink" href="../javadoc/org/gradle/nativeplatform/test/cunit/CUnitTestSuiteBinarySpec.html" target="_top"><code class="classname">CUnitTestSuiteBinarySpec</code></a>, Gradle will create a task to execute this binary,
                which will run all of the registered CUnit tests.
                Test results will be found in the <code class="literal"><em class="replaceable"><code>${build.dir}</code></em>/test-results</code> directory.
            </p><div class="example"><a name="completeCUnitExample"></a><p class="title"><b>Example&nbsp;55.32.&nbsp;Running CUnit tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"c"</span>
apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>

model {
    flavors {
        passing
        failing
    }
    repositories {
        libs(PrebuiltLibraries) {
            cunit {
                headers.srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"lib/cunit/2.1-2/include"</span>
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile =
                        file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"lib/cunit/2.1-2/lib/"</span> +
                             findCUnitLibForPlatform(targetPlatform))
                }
            }
        }
    }
}

libraries {
    operators {}
}
binaries.withType(CUnitTestSuiteBinarySpec) {
    lib library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>, linkage: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"static"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.failing) {
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"PLUS_BROKEN"</span>
    }
}</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/cunit</code> which is in both the binary and source distributions of Gradle.</p></div><p>Output of <strong class="userinput"><code>gradle -q runFailingOperatorsTestCUnitExe</code></strong></p><pre class="screen">&gt; gradle -q runFailingOperatorsTestCUnitExe
There were test failures:
  1. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/c/test_plus.c:6  - plus(0, -2) == -2
  2. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/c/test_plus.c:7  - plus(2, 2) == 4</pre></div></div><br class="example-break"></div><div class="note"><p>
                The current support for CUnit is quite rudimentary. Plans for future integration include:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Allow tests to be declared with Javadoc-style annotations.</p></li><li class="listitem"><p>Improved HTML reporting, similar to that available for JUnit.</p></li><li class="listitem"><p>Real-time feedback for test execution.</p></li><li class="listitem"><p>Support for additional test frameworks.</p></li></ul></div></div></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="Chapter&nbsp;54.&nbsp;The Signing Plugin">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="Chapter&nbsp;56.&nbsp;The Build Lifecycle">Next</a></div></div></div></body></html>